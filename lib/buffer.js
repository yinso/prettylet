// Generated by CoffeeScript 1.10.0
(function() {
  var Buffer,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Buffer = (function() {
    function Buffer(limit, tab) {
      this.limit = limit;
      this.tab = tab != null ? tab : '  ';
      this.lines = [];
      this.newLine();
    }

    Buffer.prototype.branch = function() {
      var buffer;
      buffer = new Buffer(this.limit);
      buffer.prev = this;
      buffer.continuePreviousLine = true;
      return buffer;
    };

    Buffer.prototype.merge = function(sub) {
      var i, j, len, line, ref;
      if (sub.prev === this) {
        ref = sub.lines;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          line = ref[i];
          if (sub.continuePreviousLine && i === 0) {
            this.pushArray(line);
          } else {
            this.lines.push(line);
          }
        }
        this.lastLine = this.lines[this.lines.length - 2];
        return this.currentLine = this.lines[this.lines.length - 1];
      } else {
        throw {
          cannotMerge: 'Not_connected_to_current_buffer'
        };
      }
    };

    Buffer.prototype.flexTab = function() {
      var level, precede, ref;
      level = arguments[0], precede = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (ref = this.currentLine[this.currentLine.length - 1], indexOf.call(precede, ref) >= 0) {
        return this.pushOneLine(' ');
      } else {
        return this.fixedTab(level);
      }
    };

    Buffer.prototype.fixedTab = function(level) {
      var i;
      if (this.currentLine.length > 0) {
        this.newLine();
      }
      return this.pushArray((function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = level; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push(this.tab);
        }
        return results;
      }).call(this));
    };

    Buffer.prototype.wordedTab = function(level) {
      var i, idx, j, ref, results, str;
      if (this.currentLine.length > 0) {
        this.newLine();
      }
      results = [];
      for (idx = j = 0, ref = level; 0 <= ref ? j < ref : j > ref; idx = 0 <= ref ? ++j : --j) {
        if (this.lastLine[idx]) {
          str = ((function() {
            var k, ref1, results1;
            results1 = [];
            for (i = k = 0, ref1 = this.lastLine[idx].length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
              results1.push(' ');
            }
            return results1;
          }).call(this)).join('');
          results.push(this.push(str));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Buffer.prototype.newLine = function(currentLine) {
      if (currentLine == null) {
        currentLine = this.currentLine;
      }
      this.lastLine = currentLine;
      this.currentLine = [];
      return this.lines.push(this.currentLine);
    };

    Buffer.prototype.pushOneLine = function() {
      var items;
      items = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.pushArray(items, true);
    };

    Buffer.prototype.push = function() {
      var items;
      items = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.pushArray(items);
    };

    Buffer.prototype.top = function() {
      return this.currentLine[this.currentLine.length - 1];
    };

    Buffer.prototype.pushArray = function(items, checkExceeds) {
      var item, j, len, results;
      if (checkExceeds == null) {
        checkExceeds = false;
      }
      results = [];
      for (j = 0, len = items.length; j < len; j++) {
        item = items[j];
        if (checkExceeds && this.exceedsLimit(item)) {
          throw {
            exceedsLimit: this.limit,
            item: item
          };
        }
        results.push(this.currentLine.push(item));
      }
      return results;
    };

    Buffer.prototype.currentLength = function() {
      return this.currentLine.join('').length;
    };

    Buffer.prototype.exceedsLimit = function(item) {
      var length;
      length = item.length + this.currentLine.join('').length;
      return length > this.limit;
    };

    Buffer.prototype.flatten = function(acc) {
      var j, len, line, ref;
      if (acc == null) {
        acc = [];
      }
      if (this.prev) {
        this.prev.flatten(acc);
      }
      ref = this.lines;
      for (j = 0, len = ref.length; j < len; j++) {
        line = ref[j];
        acc.push(line.join(''));
      }
      return acc;
    };

    Buffer.prototype.join = function() {
      var acc;
      acc = [];
      this.flatten(acc);
      return acc.join('\n');
    };

    return Buffer;

  })();

  module.exports = Buffer;

}).call(this);
